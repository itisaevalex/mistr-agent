/**
 * Direct hooks into the MCP Adapter
 */

import { McpAdapter } from './mcp-adapter';
import { toolStateManager } from './tool-state-manager';

/**
 * Install hooks for the McpAdapter to track tool usage
 * This uses a direct approach to hook into the adapter's methods
 */
export function installMcpAdapterHooks(adapter: McpAdapter) {
  // Only patch once
  if ((adapter as any).__hooksInstalled) {
    return;
  }
  
  console.log('üì° Installing MCP Adapter hooks to track tool usage...');
  
  try {
    // Get the prototype to patch methods
    const proto = Object.getPrototypeOf(adapter);
    
    // Patch the executeToolCalls method to track tool execution
    const originalExecToolCalls = proto.executeToolCalls;
    
    if (originalExecToolCalls) {
      proto.executeToolCalls = async function(toolCalls: any[]) {
        const conversationId = Array.from(this.conversations.keys())[0];
        
        if (conversationId && toolCalls.length > 0) {
          const firstTool = toolCalls[0];
          const toolName = firstTool?.function?.name;
          const toolArgs = firstTool?.function?.arguments;
          
          if (toolName) {
            console.log(`üîß STARTING TOOL: ${toolName} for conversation ${conversationId}`);
            
            // Check if this tool requires approval
            const securityManager = this.getSecurityManager();
            const requiresApproval = securityManager.doesToolRequireApproval(toolName);
            
            if (requiresApproval) {
              console.log(`üîí Tool ${toolName} requires approval`);
              
              try {
                // Wait for user approval via the state manager
                const approved = await toolStateManager.waitForToolApproval(conversationId, toolName, toolArgs);
                
                if (!approved) {
                  console.log(`üëé User denied tool usage for ${toolName}`);
                  throw new Error(`Security check failed: User denied approval for this operation`);
                }
                
                console.log(`üëç User approved tool usage for ${toolName}`);
              } catch (error) {
                console.error(`‚ùå Error in approval process:`, error);
                throw new Error(`Security check failed: ${error.message || 'Approval process failed'}`);
              }
            }
            
            // If we get here, either the tool was approved or doesn't need approval
            await toolStateManager.startToolUsage(conversationId, toolName);
          }
        }
        
        // Call the original method
        try {
          const result = await originalExecToolCalls.apply(this, arguments);
          
          // Tool execution completed
          if (conversationId) {
            console.log(`‚úÖ TOOL COMPLETED for conversation ${conversationId}`);
            await toolStateManager.endToolUsage();
          }
          
          return result;
        } catch (error) {
          // Tool execution failed
          if (conversationId) {
            console.log(`‚ùå TOOL FAILED for conversation ${conversationId}:`, error);
            await toolStateManager.endToolUsage();
          }
          
          throw error;
        }
      };
      
      // Patch the sendMessage method to track when processing starts/ends
      const originalSendMessage = proto.sendMessage;
      
      if (originalSendMessage) {
        proto.sendMessage = async function(conversationId: string, prompt: string) {
          console.log(`üì® STARTING MESSAGE for conversation ${conversationId}`);
          
          // Update the state to thinking
          await toolStateManager.setThinking(conversationId);
          
          try {
            const result = await originalSendMessage.apply(this, arguments);
            
            // Processing completed
            console.log(`üì© MESSAGE COMPLETED for conversation ${conversationId}`);
            await toolStateManager.setIdle(conversationId);
            
            return result;
          } catch (error) {
            // Processing failed
            console.log(`üìâ MESSAGE FAILED for conversation ${conversationId}:`, error);
            await toolStateManager.setIdle(conversationId);
            
            throw error;
          }
        };
      }
      
      // Mark as patched
      (adapter as any).__hooksInstalled = true;
      
      console.log('‚úÖ MCP Adapter hooks installed successfully!');
    } else {
      console.error('‚ùå Could not find executeToolCalls method to patch');
    }
  } catch (error) {
    console.error('‚ùå Failed to install MCP Adapter hooks:', error);
  }
}
